# List all user functions from lib/ and functions/ directories
# Use 'zman --help' for more information.

local -A _fn=(
    [info]="List all user functions from lib/ and functions/ directories"
    [desc]="Scans the zconfig lib/ and functions/ directories for function definitions
            and displays them with their descriptions. Supports filtering, grouping, and
            markdown export."
    [version]="0.5.0"
    [created]="2025"
    [modified]="2026-02-02"
    [license]="MIT"
    [author]="Andrzej Barabasz"
    [notes]="Functions starting with _ are excluded from the listing."
)

local -a _fn_args=(
    "keyword|Filter results (case-insensitive)|o"
)

local -a _fn_opts=(
    "group|g|Group functions by source file/directory"
    "markdown|m|Output as markdown table (excludes -g)"
)

local -a _fn_examples=(
    "zman|List all functions"
    "zman array|Filter functions containing 'array'"
    "zman -g -group --group group file--group.txt|Group by source file"
    "zman -m > funcs.md|Export to markdown"
)

local -A opts=() args=()
_fn_init "$@" || return $REPLY

# Options -g and -m are mutually exclusive
if (( ${+opts[group]} && ${+opts[markdown]} )); then
    printe "Options -g and -m are mutually exclusive"
    return 1
fi

local keyword="${args[keyword]:-}"
local zsh_dir="${ZDOTDIR:-${XDG_CONFIG_HOME:-$HOME/.config}/zsh}"
local lib_dir="$zsh_dir/lib"
local func_dir="$zsh_dir/functions"

# Arrays to store results
local -a funcs=() sources=() descs=()

# Parse functions from /functions directory
local file fname desc line
for file in "$func_dir"/*(.N); do
    fname="${file:t}"
    [[ "$fname" == _* ]] && continue
    IFS= read -r desc < "$file"
    desc="${desc#\#}"
    desc="${desc## }"

    funcs+=("$fname")
    sources+=("functions")
    descs+=("$desc")
done

# Parse functions from /lib directory
local -a comment_block=()
for file in "$lib_dir"/*.zsh(.N); do
    local src_name="${file:t}"
    [[ "$src_name" == "temp.zsh" ]] && continue
    comment_block=()

    while IFS= read -r line; do
        if [[ "$line" =~ '^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\)' ]]; then
            fname="${match[1]}"
            [[ "$fname" == _* ]] && continue
            desc=""
            if (( ${#comment_block} > 0 )); then
                desc="${comment_block[1]#\#}"
                desc="${desc## }"
            fi

            funcs+=("$fname")
            sources+=("$src_name")
            descs+=("$desc")
            comment_block=()
        elif [[ "$line" == \#* ]]; then
            comment_block+=("$line")
        else
            comment_block=()
        fi
    done < "$file"
done

# Calculate column widths
local max_name=0 max_src=0 i
for ((i=1; i<=${#funcs}; i++)); do
    (( ${#funcs[i]} > max_name )) && max_name=${#funcs[i]}
    (( ${#sources[i]} > max_src )) && max_src=${#sources[i]}
done
(( max_name += 2 ))
(( max_src += 2 ))

# Lowercase keyword for case-insensitive matching
local keyword_lower="${(L)keyword}"

# Case-insensitive highlight (sets REPLY)
_zman_highlight() {
    local text="$1" col_hl="$2" col_restore="$3"
    local lower_text="${(L)text}" kw_len=${#keyword}
    local result="" i=0

    while (( i < ${#text} )); do
        if [[ "${lower_text:$i:$kw_len}" == "$keyword_lower" ]]; then
            result+="${col_hl}${text:$i:$kw_len}${col_restore}"
            (( i += kw_len ))
        else
            result+="${text:$i:1}"
            (( i++ ))
        fi
    done
    REPLY="$result"
}

# Case-insensitive match check
_zman_matches() {
    [[ "${(L)1}" == *"$keyword_lower"* ]]
}

# Print a single entry (returns 1 if filtered out)
_zman_print_entry() {
    local name="$1" src="$2" desc="$3" indent="${4:-}"
    local name_col src_col desc_col name_pad src_pad

    if [[ -n "$keyword" ]]; then
        if ! _zman_matches "$name" && ! _zman_matches "$src" && ! _zman_matches "$desc"; then
            return 1
        fi
        _zman_highlight "$name" "$y" "$g"; name_col="$REPLY"
        _zman_highlight "$src" "$y" "$c"; src_col="$REPLY"
        _zman_highlight "$desc" "$y" "$w"; desc_col="$REPLY"
    else
        name_col="$name"
        src_col="$src"
        desc_col="$desc"
    fi

    (( name_pad = max_name - ${#name} ))
    (( src_pad = max_src - ${#src} ))

    if [[ -n "$src" ]]; then
        print -r -- "${indent}${g}${name_col}${(l:name_pad:: :)}${x}${c}${src_col}${(l:src_pad:: :)}${x}${w}${desc_col}${x}"
    else
        print -r -- "${indent}${g}${name_col}${(l:name_pad:: :)}${x}${w}${desc_col}${x}"
    fi
    return 0
}

# Create sorted indices array
local -a sorted_indices=() sortable=()
for ((i=1; i<=${#funcs}; i++)); do
    sortable+=("${funcs[i]}:$i")
done
sortable=(${(o)sortable})
for entry in "${sortable[@]}"; do
    sorted_indices+=("${entry##*:}")
done

# Count functions in a group (sets REPLY)
_zman_count_group() {
    local target_src="$1" count=0
    for idx in "${sorted_indices[@]}"; do
        if [[ "${sources[idx]}" == "$target_src" ]]; then
            if [[ -z "$keyword" ]] || _zman_matches "${funcs[idx]}" || \
               _zman_matches "$target_src" || _zman_matches "${descs[idx]}"; then
                (( count++ ))
            fi
        fi
    done
    REPLY=$count
}

local total_count=0

# Output based on mode
if (( ${+opts[markdown]} )); then
    print "| function | location | description |"
    print "| -------- | -------- | ----------- |"

    for idx in "${sorted_indices[@]}"; do
        local name="${funcs[idx]}" src="${sources[idx]}" desc="${descs[idx]}"
        if [[ -n "$keyword" ]]; then
            _zman_matches "$name" || _zman_matches "$src" || _zman_matches "$desc" || continue
        fi
        desc="${desc//|/\\|}"
        print "| ${name} | ${src} | ${desc} |"
        (( total_count++ ))
    done

elif (( ${+opts[group]} )); then
    local group_count=0

    _zman_count_group "functions"
    group_count=$REPLY
    if (( group_count > 0 )); then
        print "${c}functions${x} ($group_count)"
        for idx in "${sorted_indices[@]}"; do
            [[ "${sources[idx]}" == "functions" ]] && \
                _zman_print_entry "${funcs[idx]}" "" "${descs[idx]}" "    " && (( total_count++ ))
        done
    fi

    local -a lib_sources=()
    for ((i=1; i<=${#sources}; i++)); do
        [[ "${sources[i]}" != "functions" ]] && lib_sources+=("${sources[i]}")
    done
    lib_sources=(${(uo)lib_sources})

    for src in "${lib_sources[@]}"; do
        _zman_count_group "$src"
        group_count=$REPLY
        if (( group_count > 0 )); then
            print "${c}${src}${x} ($group_count)"
            for idx in "${sorted_indices[@]}"; do
                [[ "${sources[idx]}" == "$src" ]] && \
                    _zman_print_entry "${funcs[idx]}" "" "${descs[idx]}" "    " && (( total_count++ ))
            done
        fi
    done

else
    print -r -- "${y}function${(l:$(( max_name - 8 )):: :)}location${(l:$(( max_src - 8 )):: :)}description${x}"

    for idx in "${sorted_indices[@]}"; do
        _zman_print_entry "${funcs[idx]}" "${sources[idx]}" "${descs[idx]}" && (( total_count++ ))
    done
fi

(( ! ${+opts[markdown]} )) && print "\nTotal: $total_count functions"
